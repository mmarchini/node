// Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "include/v8-postmortem-debugger.h"
#include "src/assembler-arch.h"
#include "src/elements.h"
#include "src/frame-constants.h"
#include "src/frames.h"
#include "src/isolate.h"
#include "src/objects.h"
#include "src/v8memory.h"

namespace v8 {
namespace internal {

// PostmortemDebuggerStatics is responsible for setting any static and thread-
// local data that might be used during the printing routines.
class PostmortemDebuggerStatics {
 public:
  PostmortemDebuggerStatics(ThreadLocalAccessFunction t, StaticAccessFunction s)
      : tls_accessor_(t), static_accessor_(s) {}

  ~PostmortemDebuggerStatics() {
    for (base::Thread::LocalStorageKey key : local_storage_keys_) {
      base::Thread::DeleteThreadLocalKey(key);
    }
  }

  // Copies static and global data from the debuggee to this process. Returns
  // whether it succeeded.
  bool SetStatics() {
    // This list is maintained by trial and error; if you find an access
    // violation, we probably need to add more things here.
    uint8_t* embedded_blob = 0;
    uint32_t embedded_blob_size = 0;
    bool result =
#if DEBUG
        GetStaticData("v8::internal::Isolate::isolate_key_created_",
                      &Isolate::isolate_key_created_) &&
#endif
        GetStaticData("v8::internal::ElementsAccessor::elements_accessors_",
                      &ElementsAccessor::elements_accessors_) &&
        GetStaticData("v8::internal::Isolate::current_embedded_blob_",
                      &embedded_blob) &&
        GetStaticData("v8::internal::Isolate::current_embedded_blob_size_",
                      &embedded_blob_size) &&
        GetStaticData("v8::internal::Isolate::isolate_key_",
                      &Isolate::isolate_key_);
    Isolate::current_embedded_blob_ = embedded_blob;
    Isolate::current_embedded_blob_size_ = embedded_blob_size;
    Isolate::isolate_key_ = CopyThreadLocal(Isolate::isolate_key_);
    return result;
  }

 private:
  ThreadLocalAccessFunction tls_accessor_;
  StaticAccessFunction static_accessor_;
  std::vector<base::Thread::LocalStorageKey> local_storage_keys_;

  template <typename T>
  bool GetStaticData(const char* name, T* destination) {
    StaticAccessResult result = static_accessor_(
        name, reinterpret_cast<uint8_t*>(destination), sizeof(T));
    switch (result) {
      case StaticAccessResult::kOk:
        return true;
      case StaticAccessResult::kSymbolNotFound:
        std::cout << "Failed to find debug symbols for " << name
                  << ". Make sure to compile with symbol_level=2 and load the "
                     "symbols in your debugger.\n";
        return false;
      case StaticAccessResult::kMemoryNotAccessible:
        std::cout << "Couldn't read memory for " << name
                  << " in debuggee. If you are debugging a crash dump, it may "
                     "not contain the necessary memory regions.\n";
        return false;
      case StaticAccessResult::kBufferTooSmall:
        std::cout << "Data size of " << name
                  << " in dump inspector doesn't match debuggee. Are you "
                     "running the same version?\n";
        return false;
      default:
        std::cout << "Unknown error fetching " << name << ".\n";
        return false;
    }
  }

  // Copies a piece of thread local data from the debuggee to the local storage
  // of the current thread. Because TLS keys are generated by the OS, the data
  // might end up at a different index than was provided; the new index is
  // returned.
  base::Thread::LocalStorageKey CopyThreadLocal(
      base::Thread::LocalStorageKey key) {
    base::Thread::LocalStorageKey new_key =
        base::Thread::CreateThreadLocalKey();
    local_storage_keys_.push_back(new_key);
    base::Thread::SetThreadLocal(new_key, tls_accessor_(key));
    return new_key;
  }
};

}  // namespace internal
}  // namespace v8

extern "C" {

V8_EXPORT void V8PostmortemPrintObject(void* object, RegisterAccessFunction r,
                                       ThreadLocalAccessFunction t,
                                       StaticAccessFunction s) {
  v8::internal::PostmortemDebuggerStatics statics(t, s);
  if (!statics.SetStatics()) return;
  v8::internal::Object(reinterpret_cast<v8::internal::Address>(object))
      ->Print();
}

V8_EXPORT void V8PostmortemPrintStackTrace(uintptr_t stack_pointer,
                                           uintptr_t program_counter,
                                           RegisterAccessFunction r,
                                           ThreadLocalAccessFunction t,
                                           StaticAccessFunction s) {
  v8::internal::PostmortemDebuggerStatics statics(t, s);
  if (!statics.SetStatics()) return;

  v8::internal::Isolate* isolate = v8::internal::Isolate::Current();
  v8::internal::ThreadLocalTop* thread_local_top = isolate->thread_local_top();

  // StackTraceIterator is designed to work when called from C++ code, but
  // the dump we're debugging could have been executing JS. If that is the
  // case, we need to deal with it. We can detect JS at the top of the stack
  // if JS has been entered (non-zero js_entry_sp_), and c_entry_fp_ is not
  // set (never called into C++), or c_entry_fp_ is set but there is more JS
  // code higher up the stack (which we can check with handler_, since every
  // entry frame includes a handler).
  v8::internal::Address c_entry_fp = isolate->c_entry_fp(thread_local_top);
  v8::internal::Address js_entry_sp = isolate->js_entry_sp();
  v8::internal::Address handler = isolate->handler(thread_local_top);
  if (js_entry_sp != 0 && (c_entry_fp == 0 || handler < c_entry_fp)) {
    // Fetch current register state from the debuggee.
    // This code doesn't currently include every edge case. In particular,
    // it doesn't check whether execution is currently in a prolog or
    // epilog, and doesn't support embedded constant pool (PPC only).
    v8::internal::StackFrame::State state;
    state.sp = stack_pointer;
    state.fp = r(v8::internal::JavaScriptFrame::fp_register().code());
    state.pc_address = &program_counter;

    isolate->PrintStack(stdout, v8::internal::Isolate::kPrintStackVerbose,
                        &state);
  } else {
    isolate->PrintStack(stdout);
  }
}

}  // extern "C"
