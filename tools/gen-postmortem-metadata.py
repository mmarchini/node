#!/usr/bin/env python

#
# gen-postmortem-metadata.py output_file.cc
#
# Creates debugging symbols to help naviage Node's internals using post-mortem
# debugging tools.
#

import sys


class DebugSymbol(object):
    type_ = 'int'
    _PREFIX = 'nodedbg_'

    def __init__(self, name, value, headers=[], type_=None):
        self.name = name
        self.value = value
        self.headers = headers
        self.type_ = type_ or DebugSymbol.type_

    @classmethod
    def get_headers(cls, debug_symbols):
        seen = set()
        seen_add = seen.add  # faster than seen.add on each iteration
        headers = [debug_symbol.headers for debug_symbol in debug_symbols]
        headers = sum(headers, [])

        return [h for h in headers if not (h in seen or seen_add(h))]

    def __str__(self):
        return "{type} {prefix}{name} = {value};".format(
            type=self.type_,
            prefix=self._PREFIX,
            name=self.name,
            value=self.value,
        )


debug_symbols = [
    DebugSymbol(
        name="currentEnvironment",
        value="(uint64_t) &Environment::currentEnvironment",
        headers=["env.h"],
        type_="uint64_t",
    ),
    DebugSymbol(
        name="class__BaseObject__persistant_handle",
        value="(size_t) &(((BaseObject*)0)->persistent())",
        headers=["base-object.h", "base-object-inl.h"],
        type_="size_t",
    ),
    DebugSymbol(
        name="class__Environment__handleWrapQueue",
        value="(size_t) (((Environment*)0)->handle_wrap_queue())",
        headers=["env.h"],
        type_="size_t",
    ),
    DebugSymbol(
        name="class__HandleWrap__node",
        value="(size_t) (((HandleWrap*)0)->handle_wrap_queue())",
        headers=["handle_wrap.h"],
        type_="size_t",
    ),
    DebugSymbol(
        name="class__HandleWrapQueue__headOffset",
        value="(size_t) (((Environment::HandleWrapQueue*)0)->head())",
        headers=["env.h"],
        type_="size_t",
    ),
    DebugSymbol(
        name="class__HandleWrapQueue__nextOffset",
        value="(size_t) (((ListNode<HandleWrap>*)0)->next())",
        headers=["handle_wrap.h", "util.h"],
        type_="size_t",
    ),
    DebugSymbol(
        name="class__Environment__reqWrapQueue",
        value="(size_t) (((Environment*)0)->req_wrap_queue())",
        headers=["env.h"],
        type_="size_t",
    ),
    DebugSymbol(
        name="class__ReqWrap__node",
        value="(size_t) (((ReqWrap<uv_req_t>*)0)->req_wrap_queue())",
        headers=["req-wrap.h"],
        type_="size_t",
    ),
    DebugSymbol(
        name="class__ReqWrapQueue__headOffset",
        value="(size_t) (((Environment::ReqWrapQueue*)0)->head())",
        headers=["env.h"],
        type_="size_t",
    ),
    DebugSymbol(
        name="class__ReqWrapQueue__nextOffset",
        value="(size_t) (((ListNode<ReqWrap<uv_req_t>>*)0)->next())",
        headers=["req-wrap.h", "util.h"],
        type_="size_t",
    ),
]


template = '''
/*
 * This file is generated by {filename}.  Do not edit directly.
 */

{includes}

using namespace node;

extern "C" {{
{symbols}
}}
'''


def create_symbols_file():
    out = file(sys.argv[1], 'w')
    headers = DebugSymbol.get_headers(debug_symbols)
    includes = ['#include "{}"'.format(header) for header in headers]
    includes = "\n".join(includes)

    symbols = "\n".join([str(symbol) for symbol in debug_symbols])

    out.write(template.format(
        filename=sys.argv[0],
        includes=includes,
        symbols=symbols,
    ))


if (len(sys.argv) < 2):
    print('usage: %s output.cc' % sys.argv[0])
    sys.exit(2)


create_symbols_file()
