/*
 * This file is generated by ./tools/gen-postmortem-metadata.py.  Do not edit directly.
 */

// Need to import standard headers before redefining private, otherwise it
// won't compile
#include <algorithm>
#include <array>
#include <atomic>
#include <bitset>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstdarg>
#include <cstddef>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <exception>
#include <forward_list>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iosfwd>
#include <iostream>
#include <istream>
#include <iterator>
#include <limits>
#include <list>
#include <map>
#include <memory>
#include <new>
#include <ostream>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <streambuf>
#include <string>
#include <tuple>
#include <type_traits>
#include <typeinfo>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

int GenDebugSymbol();

#define private friend int GenDebugSymbol(); private

#define nonstandard_offsetof(CLASS, FIELD) reinterpret_cast<uintptr_t>        (&(static_cast<CLASS*>(0)->FIELD))

#include "env.h"
#include "base_object-inl.h"
#include "handle_wrap.h"
#include "util.h"
#include "req_wrap.h"

int nodedbg_environment_context_idx_embedder_data;
size_t nodedbg_class__BaseObject__persistent_handle;
size_t nodedbg_class__Environment__handleWrapQueue;
size_t nodedbg_class__HandleWrap__node;
size_t nodedbg_class__HandleWrapQueue__headOffset;
size_t nodedbg_class__HandleWrapQueue__nextOffset;
size_t nodedbg_class__Environment__reqWrapQueue;
size_t nodedbg_class__ReqWrap__node;
size_t nodedbg_class__ReqWrapQueue__headOffset;
size_t nodedbg_class__ReqWrapQueue__nextOffset;

namespace node {

int GenDebugSymbol() {
nodedbg_environment_context_idx_embedder_data = Environment::kContextEmbedderDataIndex;
nodedbg_class__BaseObject__persistent_handle = nonstandard_offsetof(BaseObject, persistent_handle_);
nodedbg_class__Environment__handleWrapQueue = nonstandard_offsetof(Environment, handle_wrap_queue_);
nodedbg_class__HandleWrap__node = nonstandard_offsetof(HandleWrap, handle_wrap_queue_);
nodedbg_class__HandleWrapQueue__headOffset = offsetof(Environment::HandleWrapQueue, head_);
nodedbg_class__HandleWrapQueue__nextOffset = offsetof(ListNode<HandleWrap>, next_);
nodedbg_class__Environment__reqWrapQueue = nonstandard_offsetof(Environment, req_wrap_queue_);
nodedbg_class__ReqWrap__node = nonstandard_offsetof(ReqWrap<uv_req_t>, req_wrap_queue_);
nodedbg_class__ReqWrapQueue__headOffset = offsetof(Environment::ReqWrapQueue, head_);
nodedbg_class__ReqWrapQueue__nextOffset = offsetof(ListNode<ReqWrap<uv_req_t>>, next_);
return 1;
}

int debug_symbols_generated = GenDebugSymbol();

}


/*
 * This file is generated by ./tools/gen-postmortem-metadata.py.  Do not edit directly.
 */

#include "gtest/gtest.h"
#include "../../../../test/cctest/node_test_fixture.h"
#include "node.h"
#include "node_internals.h"
#include "udp_wrap.h"
#include "v8.h"

class DebugSymbolsTest : public NodeTestFixture {
};


class TestHandleWrap : public node::HandleWrap {
  public:
   size_t self_size() const override { return sizeof(*this); }

   TestHandleWrap(node::Environment* env, v8::Local<v8::Object> object, uv_handle_t* handle) :
     node::HandleWrap(env, object, handle, node::AsyncWrap::PROVIDER_TIMERWRAP) {}
};



TEST_F(DebugSymbolsTest, ContextEmbedderDataIndex) {
  EXPECT_EQ(nodedbg_environment_context_idx_embedder_data, node::Environment::kContextEmbedderDataIndex);
}


TEST_F(DebugSymbolsTest, BaseObjectPersistentHandle) {
  v8::HandleScope handle_scope(isolate_);
  auto context = node::NewContext(isolate_);
  v8::Context::Scope context_scope(context);
  node::IsolateData* isolateData = node::CreateIsolateData(isolate_, uv_default_loop());
  Argv argv{"node", "-e", ";"};
  auto env = node::CreateEnvironment(isolateData, context, 1, *argv, 2, *argv);

  v8::Local<v8::Object> object = v8::Object::New(isolate_);
  node::BaseObject *obj = new node::BaseObject(env, object);

  EXPECT_EQ((void *)&(obj->persistent()), (((void*)obj) + nodedbg_class__BaseObject__persistent_handle));

  // FIXME throws an error
  // delete obj;
}


TEST_F(DebugSymbolsTest, EnvironmentHandleWrapQueue) {
  v8::HandleScope handle_scope(isolate_);
  auto context = node::NewContext(isolate_);
  v8::Context::Scope context_scope(context);
  node::IsolateData* isolateData = node::CreateIsolateData(isolate_, uv_default_loop());
  Argv argv{"node", "-e", ";"};
  auto env = node::CreateEnvironment(isolateData, context, 1, *argv, 2, *argv);

  EXPECT_EQ((void *)(env->handle_wrap_queue()), (((void*)env) + nodedbg_class__Environment__handleWrapQueue));
}


TEST_F(DebugSymbolsTest, HandleWrapList) {
  v8::HandleScope handle_scope(isolate_);
  auto context = node::NewContext(isolate_);
  v8::Context::Scope context_scope(context);
  node::IsolateData* isolateData = node::CreateIsolateData(isolate_, uv_default_loop());
  Argv argv{"node", "-e", ";"};
  auto env = node::CreateEnvironment(isolateData, context, 1, *argv, 2, *argv);

  uv_handle_t handle_;


  auto lala_template = v8::FunctionTemplate::New(isolate_);
  lala_template->SetClassName(FIXED_ONE_BYTE_STRING(isolate_, "lala"));
  lala_template->InstanceTemplate()->SetInternalFieldCount(1);

  v8::Local<v8::Object> object = lala_template->GetFunction()->NewInstance(context).ToLocalChecked();
  // v8::Local<v8::Integer> intval = v8::Integer::New(isolate_, 5);
  // object->Set(FIXED_ONE_BYTE_STRING(isolate_, "TestWrapper"), intval);
  auto *obj = new TestHandleWrap(env, object, &handle_);


  // EXPECT_EQ((void *)(env->handle_wrap_queue()), (((void*)env) + nodedbg_class__Environment__handleWrapQueue));
}


TEST_F(DebugSymbolsTest, EnvironmentReqWrapQueue) {
  v8::HandleScope handle_scope(isolate_);
  auto context = node::NewContext(isolate_);
  v8::Context::Scope context_scope(context);
  node::IsolateData* isolateData = node::CreateIsolateData(isolate_, uv_default_loop());
  Argv argv{"node", "-e", ";"};
  auto env = node::CreateEnvironment(isolateData, context, 1, *argv, 2, *argv);

  EXPECT_EQ((void *)(env->req_wrap_queue()), (((void*)env) + nodedbg_class__Environment__reqWrapQueue));
}
